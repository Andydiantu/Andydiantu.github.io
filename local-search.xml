<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Leetcode 287与Floyd判圈算法</title>
    <link href="/2022/01/09/FloydAlgorithms/"/>
    <url>/2022/01/09/FloydAlgorithms/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1><p>今天的题目是Leetcode编号为276的题目，是一道乍看很简单，不过在考虑所有的constrain之后会发现很难的题目。要在所有的条件下解出这道题会用到Floyd判圈算法，也称龟兔赛跑算法，Floyd判圈算法可以用于检测链表，迭代算法中是否存在环(circle)。</p><h1 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> <a href="https://leetcode.com/problems/find-the-duplicate-number/">题目</a></h1><p>Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive.</p><p>There is only <strong>one repeated number</strong> in nums, return this repeated number.</p><p>You must solve the problem without modifying the array nums and uses only constant extra space.</p><p><strong>Example 1:</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Input</span>:<span class="hljs-meta"> [1,2,3,4,4]</span><br><span class="hljs-attribute">Output</span>: <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode, Algorithms</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Leetcode总结]生成一个String所有partitioning</title>
    <link href="/2022/01/09/partitionining2/"/>
    <url>/2022/01/09/partitionining2/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1><p>这是我在刷今天的leetcode题目 <a href="https://leetcode.com/problems/palindrome-partitioning/">131.Palindrome Partitioning</a> 学到的技巧，在这里记录一下。</p><h1 id="问题"><a class="markdownIt-Anchor" href="#问题"></a> 问题</h1><p>给与一个String, 我们要产出他的所有的partitioning。</p><p><strong>Example 1</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">Input: <span class="hljs-string">&quot;ac&quot;</span><br><br>Output: <span class="hljs-string">[[&quot;a&quot;,&quot;c],  [&quot;ac&quot;]]</span><br></code></pre></td></tr></table></figure><p><strong>Example 2</strong></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vim">Inpu<span class="hljs-variable">t:</span> <span class="hljs-string">&quot;abc&quot;</span><br><br>Outpu<span class="hljs-variable">t:</span> [[<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c], [&quot;</span><span class="hljs-keyword">a</span><span class="hljs-string">&quot;,&quot;</span>bc<span class="hljs-string">&quot;], [&quot;</span><span class="hljs-keyword">ab</span><span class="hljs-string">&quot;, &quot;</span><span class="hljs-keyword">c</span><span class="hljs-string">&quot;], [&quot;</span><span class="hljs-keyword">abc</span><span class="hljs-comment">&quot;]]</span><br></code></pre></td></tr></table></figure><h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1><p>我们可以使用递归来解决这个问题，对于partitioning这个问题，我们可以很容易的辨别出很多更小规模的问题。比如对于整个String，我们可以求整个String的全部的partitioning，也可以求从这个String的一个subString的全部的partitioning。在分辨出了sub problem之后，我们就可以寻找不同规模问题之间的互通之处。我们选择了top down的方式来解决，从最大规模的问题层层递归到最小规模，最后求解。</p><p>对于每个String，我们先取它从头开始的每一种substring，对于一下的例子来说就是 [“a”, “ab”, “abc”]，然后对于剩下的String 递归套用一样的方法。最后的结果就会是全部的partitioning。</p><p><img src="/2022/01/09/partitionining2/pic.jpg" alt="alt"></p><h1 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; allPartitioning (String s)&#123;<br>    List&lt;List&lt;String&gt;&gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br>    dfs(ans, <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;(), <span class="hljs-number">0</span>, s);<br><br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span> <span class="hljs-params">(List&lt;List&lt;String&gt;&gt; ans, List&lt;String&gt; currList, <span class="hljs-keyword">int</span> start, String s)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(start &gt;= s.length())&#123;<br>        ans.add(<span class="hljs-keyword">new</span> ArrayList&lt;String&gt;(currList));<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> end = start; end &lt; s.length(); end++)&#123;<br>            currList.add(s.subString(start,end+<span class="hljs-number">1</span>));<br>            dfs(ans,currList, start + <span class="hljs-number">1</span>, s);<br>            <span class="hljs-comment">// backtrack and remove the substring we just added.</span><br>            currList.remove(currList.size()-<span class="hljs-number">1</span>); <br>        &#125;<br>    &#125;<br>&#125; <br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode, Algorithms</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[leetcode总结] 题目 476 与 Int 边际值</title>
    <link href="/2021/12/30/Complement/"/>
    <url>/2021/12/30/Complement/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1><p>今天的题目是Leetcode编号为476的题目，虽然是一道简单题但是里面涉及的关于Int型极值的问题让我想把他记录下来。</p><h1 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> <a href="https://leetcode.com/problems/number-complement/">题目</a></h1><p>The <strong>complement</strong> of an integer is the integer you get when you flip all the 0’s to 1’s and all the 1’s to 0’s in its binary representation.</p><p>For example, The integer 5 is “101” in binary and its complement is “010” which is the integer 2.</p><p>Given an integer num, return it’s <em>complement</em>.</p><p><strong>Example 1:</strong></p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"><span class="hljs-symbol">Input:</span> num = <span class="hljs-number">5</span><br><span class="hljs-symbol">Output:</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">Explaination:</span> The <span class="hljs-keyword">binary</span> representation <span class="hljs-keyword">of</span> <span class="hljs-number">5</span> <span class="hljs-built_in">is</span> <span class="hljs-number">101</span> (no leading zero bits), <span class="hljs-built_in">and</span> its complement <span class="hljs-built_in">is</span> <span class="hljs-number">010</span>. So you need <span class="hljs-keyword">to</span> output <span class="hljs-number">2</span>.<br></code></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"><span class="hljs-symbol">Input:</span> num = <span class="hljs-number">1</span><br><span class="hljs-symbol">Output:</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">Explaination:</span> The <span class="hljs-keyword">binary</span> representation <span class="hljs-keyword">of</span> <span class="hljs-number">1</span> <span class="hljs-built_in">is</span> <span class="hljs-number">1</span> (no leading zero bits), <span class="hljs-built_in">and</span> its complement <span class="hljs-built_in">is</span> <span class="hljs-number">0</span>. So you need <span class="hljs-keyword">to</span> output <span class="hljs-number">0</span>.<br></code></pre></td></tr></table></figure><h3 id="constaints"><a class="markdownIt-Anchor" href="#constaints"></a> Constaints:</h3><p>1 &lt;= num &lt; <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>31</mn></msup></mrow><annotation encoding="application/x-tex">2^{31}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span></p><h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1><p>每个数的complement的本质就是与这个数的二进制有着相同长度，而且每一位都是1的数与这个数的二进制的差。</p><p><strong>举例</strong></p><p>num = 5</p><p>二进制表达方式 num_in_binary = 101</p><p>与原数字有着相同长度，而且每一位都是1的二进制数 mask = 111</p><p>两个数之差：111-101 = 010 =&gt; 2 (从二进制转换到十进制)</p><p>所以 5 的complement就是 2。</p><h1 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h1><p>按照这个思路，首先我们要知道num二进制表达中有多少位。 然后根据位数来获得mask，最后做差。</p><p>获得十进制表达的数字的二进制表达的位数，我们可以通过以2为底的log操作来获得。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> num_digit_binary = (<span class="hljs-keyword">int</span>) (Math.log(num) / Math.log(<span class="hljs-number">2</span>));<br></code></pre></td></tr></table></figure><p>获得对应的mask，我们可以通过2的位数加一次再减一来获得。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> mask = (<span class="hljs-keyword">int</span>) (Math.pow(<span class="hljs-number">2</span>,num_digit_binary + <span class="hljs-number">1</span>) - <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>最后我们求两数之差就是complement了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> complement = mask - num;<br></code></pre></td></tr></table></figure><p>上述解法大部分情况可以都可以得到正确答案。不过在num_digit_binary为31位的时候, $ 2^{31}$ 存入Int会早成overflow，因为的int型的MAX_VALUE是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>31</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{31} - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，存入<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>31</mn></msup></mrow><annotation encoding="application/x-tex">2^{31}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>的结果会是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>31</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{31} - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，这时候我们再减一就会让最后mask变为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>31</mn></msup><mo>−</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">2^{31} - 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>。 我们可以通过先减一再cast成int来避免这个情况。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
